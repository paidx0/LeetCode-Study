## æ—¶é—´å¤æ‚åº¦ï¼š```log(N)```

## ç©ºé—´å¤æ‚åº¦ï¼š```log(N)```

## åŸç†ï¼š

å¦‚æœå½“å‰èŠ‚ç‚¹å€¼ä¸º **x**ï¼Œé‚£ä¹ˆ **```left.val = 2 * x + 1```** å¹¶ä¸” **```right.val = 2 * x + 2```**

ç”±æ­¤å¯çŸ¥ï¼Œ**```left.val```** ä¸€å®šä¸º **å¥‡æ•°**ï¼Œ**```right.val```** ä¸€å®šä¸º **å¶æ•°**

é‚£ä¹ˆå¯ä»¥åˆ©ç”¨è¿™ä¸€ç‰¹æ€§è¿›è¡Œ **åå‘æ¨å¯¼**

## ä¸¾ä¸ªğŸŒ°ï¼šæŸ¥æ‰¾ 13 æ˜¯å¦åœ¨æ ‘ä¸­

å› ä¸º **13** ä¸ºå¥‡æ•°ï¼Œé‚£ä¹ˆé€šè¿‡ ```2 * x + 1 === 13``` å¯å¾— ```x === 6``` , **6** çš„ ```left``` ä¸º **13**

é€’å½’æŸ¥æ‰¾ **6**

å› ä¸º **6** ä¸ºå¶æ•°ï¼Œé‚£ä¹ˆé€šè¿‡ ```2 * x + 2 === 6``` å¯å¾— ```x === 2```, **2** çš„ ```right``` ä¸º **6**

ä¸Šè¿°æ“ä½œè¿›è¡Œé€’å½’å¤„ç†ï¼Œæœ€ç»ˆå¾—åˆ°ä¸€ä¸ªè®¿é—®è·¯å¾„æ ˆ ```stack```

* typescript

```typescript
[
  { val: 6, nextDirection: 'left' },
  { val: 2, nextDirection: 'right' },
  { val: 0, nextDirection: 'right' },
]
// æ³¨ï¼šå®é™…è¿‡ç¨‹å¯ä¸å­˜å‚¨ val å€¼
// ä¸Šè¿°è¿‡ç¨‹è¡¨ç¤ºï¼š
// 0 çš„ right ä¸º 2
// 2 çš„ right ä¸º 6
// 6 çš„ left ä¸º target
```

## æ€»ç»“ï¼š

1. å…ˆé€’å½’æŸ¥æ‰¾è®¿é—®è·¯å¾„ï¼Œä»è€Œå¾—åˆ°ä¸€ä¸ª ```nextDirection``` æ ˆ
2. ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œå½“ ```root``` åŠ ```stack``` ä¸ä¸ºç©ºçš„æ—¶å€™ï¼Œä¾æ¬¡å¯¹æ ˆé¡¶å…ƒç´ è¿›è¡Œå‡ºæ ˆå¤„ç†
3. æœ€ç»ˆåˆ¤æ–­ ```stack``` ä¸ºç©ºæ—¶ï¼Œ```root.val``` æ˜¯å¦ç­‰äº ```target```

## å®Œæ•´ä»£ç ï¼ˆTypeScriptï¼‰ï¼š

* typescript

```typescript
class FindElements {
    constructor(private root: TreeNode | null) {
        this.root = this.recoverTree(root, 0)
    }
    
    find(target: number): boolean {
        if (target === 0) return true
        
        // 1.è¿˜åŸè®¿é—®è·¯å¾„
        const stack = this.recoverPath(target, [])
        
        // 2.æŸ¥æ‰¾
        let root = this.root
        while(stack.length && root) {
            const direction = stack.pop()
            root = root[direction]
        }
        return stack.length > 0 || !root ? false : root.val === target
    }
    
    /**
     * åˆ©ç”¨ left ä¸ºå¥‡æ•°ï¼Œright ä¸ºå¶æ•°ç‰¹æ€§è¿˜åŸè®¿é—®è·¯å¾„
     */
    private recoverPath(target: number, stack: ('left' | 'right')[]) {
        if (target === 0) return stack
        
        let v:number
        if (target % 2 === 0) {
            v = (target - 2) / 2
            stack.push('right')
        } else {
            v = (target - 1) / 2
            stack.push('left')
        }
        
        this.recoverPath(v, stack)
        return stack
    }
    
    /**
     * æ¢å¤è¢«æ±¡æŸ“çš„æ ‘
    */
    private recoverTree(root: TreeNode | null, v: number) {
        if (!root)  return
        
        root.val = v
        this.recoverTree(root.left, v * 2 + 1)
        this.recoverTree(root.right, v * 2 + 2)
        return root
    }
}
```

