## 时间复杂度：```log(N)```

## 空间复杂度：```log(N)```

## 原理：

如果当前节点值为 **x**，那么 **```left.val = 2 * x + 1```** 并且 **```right.val = 2 * x + 2```**

由此可知，**```left.val```** 一定为 **奇数**，**```right.val```** 一定为 **偶数**

那么可以利用这一特性进行 **反向推导**

## 举个🌰：查找 13 是否在树中

因为 **13** 为奇数，那么通过 ```2 * x + 1 === 13``` 可得 ```x === 6``` , **6** 的 ```left``` 为 **13**

递归查找 **6**

因为 **6** 为偶数，那么通过 ```2 * x + 2 === 6``` 可得 ```x === 2```, **2** 的 ```right``` 为 **6**

上述操作进行递归处理，最终得到一个访问路径栈 ```stack```

* typescript

```typescript
[
  { val: 6, nextDirection: 'left' },
  { val: 2, nextDirection: 'right' },
  { val: 0, nextDirection: 'right' },
]
// 注：实际过程可不存储 val 值
// 上述过程表示：
// 0 的 right 为 2
// 2 的 right 为 6
// 6 的 left 为 target
```

## 总结：

1. 先递归查找访问路径，从而得到一个 ```nextDirection``` 栈
2. 从根节点开始，当 ```root``` 及 ```stack``` 不为空的时候，依次对栈顶元素进行出栈处理
3. 最终判断 ```stack``` 为空时，```root.val``` 是否等于 ```target```

## 完整代码（TypeScript）：

* typescript

```typescript
class FindElements {
    constructor(private root: TreeNode | null) {
        this.root = this.recoverTree(root, 0)
    }
    
    find(target: number): boolean {
        if (target === 0) return true
        
        // 1.还原访问路径
        const stack = this.recoverPath(target, [])
        
        // 2.查找
        let root = this.root
        while(stack.length && root) {
            const direction = stack.pop()
            root = root[direction]
        }
        return stack.length > 0 || !root ? false : root.val === target
    }
    
    /**
     * 利用 left 为奇数，right 为偶数特性还原访问路径
     */
    private recoverPath(target: number, stack: ('left' | 'right')[]) {
        if (target === 0) return stack
        
        let v:number
        if (target % 2 === 0) {
            v = (target - 2) / 2
            stack.push('right')
        } else {
            v = (target - 1) / 2
            stack.push('left')
        }
        
        this.recoverPath(v, stack)
        return stack
    }
    
    /**
     * 恢复被污染的树
    */
    private recoverTree(root: TreeNode | null, v: number) {
        if (!root)  return
        
        root.val = v
        this.recoverTree(root.left, v * 2 + 1)
        this.recoverTree(root.right, v * 2 + 2)
        return root
    }
}
```

